
线程机制实习报告



总体概述
      线程是操作系统CPU调度最基本的单位，代表程序在给定数据集上的一次执行活动，每个线程都有自己唯一的线程编号TID，记录线程信息的数据结构为TCB。在线程创建时，也需要为线程分配内存空间。线程也有创建后的初始就绪态，占用CPU的运行态和退出后的销毁态。
      Nachos第一个需要扩充的部分就是线程管理，在nachos中有一个核心的内核级线程main，是操作系统内核初始化时第一个建立的线程，可以利用它来fork创建其余线程。也可以直接new Thread线程构造函数建立新的线程。但nachos中没有实现父子线程的继承关系。


第一部分
1 基础知识
	Nachos中的线程为Thread类，Linux中进程控制块（PCB）叫做task_struct，主要包含标识符pid：用于唯一标识进程，区别于其他进程，同时还有进程组标识；状态state：任务状态，退出代码，中断信号等；实时优先级：用于计算实时进程调度时的weight值；程序计数器：程序中即将被执行的下一条指令的地址；内存指针：存放进程内存管理信息，包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针；上下文环境：进程执行时处理器的寄存器中的数据；I/O状态信息：包括显示的I/O请求，分配给进程的I/O设备和被进程打开的文件列表；记录信息：可能包括处理器时间总和，使用的时钟总和，定时器终止时间，记账号等。
	Linux的进程状态可分为运行态，可中断和不可中断态，暂停态，终止态，僵尸状态，挂起状态等。
	在nachos系统，PCB在thread.h中实现。包括stackTop：当前栈指针；machineState未在CPU上所有寄存器的状态；fork等函数头的定义；私有属性：stack栈底指针，status进程的状态，name进程名。
	主要区别在于linux中PCB包含的信息更多，nachos中仅包含了必须的信息，并且nachos中没有限制线程的总数量。Nachos的线程机制没有实现父子线程的继承关系，只有核心线程fork产生其余线程。

2 源码阅读
Mian.cc文件：Kernel类，记录内核信息，包括当前占用cpu的线程和线程就绪队列；Copy函数，复制文件内容，如果打开失败则返回；Print函数将name文件的内容输出，利用一个设定长度的buffer多次获取数据并输出；main函数，进行变量的初始化，解析argc和argv中的命令，判断要执行的指令，调用不同的函数。并建立内核状态。
threadtest.cc文件：线程测试方法，在nachos4.1并将此功能并入了main.cc文件中。
thread.h文件
主要对于线程的定义。内存栈空间的大小8*1024，线程状态（创建、运行、就绪、阻塞），在Thread类中定义线程的数据结构，包括栈指针，未在CPU上的所有寄存器的状态，线程主要函数的预定义；stack线程栈底指针，线程名，用户寄存器的状态等。
thread.cc文件
线程fork、begin、finish、yield和sleep功能的实现。
Thread构造函数：传入线程名并初始化线程；~Thread析构函数：删除线程，assert断言表示判断布尔表达式，判断当前线程是否在运行，只有不在运行状态中的线程才能被删除；
fork函数：func参数为新线程运行的函数，函数首先复制内核线程的中断帧和进程队列，其次开辟线程内存空间，关闭中断状态准备运行当前线程最后恢复中断状态。
Checkoverflow函数：检查线程的内存空间是否溢出
Begin函数：将可运行的线程开始运行， 并允许中断
Finish函数：将正在运行中的线程睡眠
Yield函数：线程放弃cpu，并运行下一个线程
Sleep函数：线程由于某种原因进入阻塞状态等待一个事件的发生，当这些条件得到满足，该线程又可以恢复就绪状态
Stackallocate函数：为新线程申请栈空间，并设置好准备运行线程的条件。

3、Exercise 4 增加线程数据结构并实现全局线程管理机制
合并完成Exercise 3和Exercise 4，首先在thread.h中添加userid和threadid两个private的int型变量作为用户ID和线程ID，并添加两个获取对应ID的public函数。
为限制线程总数，设置一个全局的数组int ThreadIDs[MAXThreads];MAXThreads代表最大线程数，本次设为128。数组初始值均为0，每建立一个线程则将对应的位置赋为1，除主线程main（mainID为1000）外，每个线程的ID即数组中对应的下标。
对于用户ID，创建的新线程直接利用unistd.h头文件中带有的getuid函数获取当前系统的userid，测试中为1000。
对于线程ID，修改Thread线程构造函数，添加线程ID分配功能AllocateThreadID：实现的原理是每次利用一个for循环从线程数组中寻找为0位置的下标赋给新线程并设为1然后返回，如果没有找到，说明线程已分配满（对线程数量的限制）返回-1。在Thread构造函数中，ThreadID会接受分配函数的返回值，如果发现值为-1即线程数量已满，则输出“Reached MaxThreadsNum！！”，再利用ASSERT断言限制后续代码的运行，即停止新线程的创建。
当线程退出时，在~Thread析构函数中，将线程数组中线程ID下标所对应的值重新设为0。
 
在main.cc主函数文件中，添加对-t命令的解析，即最大线程数量的测试，结果如图。
 

简单TS功能的实现，直接利用scheduler.cc中的print功能输出readyList就绪队列，并加上正在执行的currentthread。
 



