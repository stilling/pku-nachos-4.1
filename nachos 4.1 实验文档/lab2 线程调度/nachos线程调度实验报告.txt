内容一：总体概述
线程是CPU调度最基本的单位，操作系统通过根据特定的调度算法为线程分配CPU实现并发功能，提高系统资源的利用效率。
线程调度算法是基于操作系统的功能设计，如I/O优先或者CPU优先，通过特定的算法为不同的线程赋予不同的优先级，对CPU进行线程的分配。
Linux中使用抢占式调度，windows操作系统中采用基于优先级的抢占式多任务调度。
具体而言，Windows采用综合调度算法调度线程，采用基于动态优先级的、抢占式调度，结合时间配额调整。采用优先队列方式，就绪队列按优先级进入相应队列，系统总是选择优先级最高的就绪线程运行；相同优先级的各线程按时间片轮转进行调度；如果是多处理机系统的话，可以允许多个线程同时并行运行。在windows中，如果一个线程的优先级改变了，或者一个线程改变了它的亲和处理机集合，则会引发线程调度。Windows采用32个线程优先级，分为实时优先级、可变优先级和系统线程三类，调度策略为主动切换、抢占和时间片用完。

内容二：源代码阅读
线程调度算法模块scheduler.h和scheduler.cc文件：
nextThread为需要切换运行的线程
Nachos的线程调度模块实现了就绪进程队列readyList，调度算法每次取出第一个线程放入处理机中运行。	
在scheduler类中，所有方法都是原子操作，不允许中断。
除构造函数和析构函数外，ReadyToRun函数：设置一个线程为就绪态；
FindNextToRun函数，找出下一个处于就绪态的进程并返回；
Run函数：切换到nextThread执行,输入为下一个要执行的线程，将当前运行强制切换到nextThread就绪线程运行；
Print函数：打印出处于就绪态的所有线程。
Switch.S文件：汇编语言代码，定义硬件操作，实现线程切换
时钟中断模块(timer.cc timer.h)：用于模拟时钟中断，中断时间为TimerTicks宏决定(可以为100倍Tick的时间也可以是一个随机值,即下一次时钟中断发生的时间)

内容三：基于优先级的抢占式调度算法的实现
实现线程的优先级调度需要先在线程中添加优先级属性以及对应的维护，添加一个新的Thread类构造函数，参数为threadname+priority线程优先级。线程调度队列的实现在synchlist文件中，因为加入了线程的优先级，在向队列中加入线程时加上对线程优先级的排序，建立sortedlist并加入对比线程优先级的compare函数，实现优先级队列。
Insert函数在队列中按优先级插入线程。在测试用例中，设置一个优先级，并运行20次，可以看到优先级更高的线程2后创建先运行。

内容四：时间片轮转的调度算法
采用动态优先权的时间片轮转算法， 利用占用CPU的时间改变线程优先级实现线程轮流占用cpu，在每次时钟中断时，重新计算线程的优先级。
在Schduler文件中进行修改，定义固定的时间片大小，线程创建时的优先级，睡眠唤醒时的优先级，优先级调整幅度，两次抢占调度的最小时间间隔等数据成员，在Schduler类中添加函数FlushPorioty()成员函数，时钟中断中调用，调整所有就绪线程的优先级。并用lastSwitchTick记录上次线程切换的时间。
线程优先级在以下几个时机下计算：
● 创建新的线程时，新线程的优先级为50
● 线程睡眠时，醒来的优先级为80
● 线程调度时，当前调整当前线程的优先级，p=p-（当前系统时间-lastSwitchTick）/20
● 时钟中断时，对所有就绪线程的优先级进行调整: p=p+5
修改原有成员函数，FindNextToRun()作为优先级调度，在调度时候先计算最近调度的间隔，如果太小则不调度。如果就绪队列优先级最高的线程仍低于当前线程，则不调度。

内容五：多级反馈队列的调度算法
算法建立多个就绪队列，优先级依次递减，第一级队列优先级最高。不同就绪队列分配长度依次增加的时间片，队列内部采用时间片轮转方式调度。
在alarm和timer类中的实现后，将scheduler类声明为callbackobj的继承类，重载callback（）同时使用interrupt类中的schedule（）函数就可以实现按优先级控制时间片，用时间片进行线程调度。
在run（）中添加使用interrupt类中的schedule（），然后在kernel类中Initialize（）中屏蔽alarm产生的随机时间中断。
实现多级反馈队列调度算法。

总结:自己动手实现，时间片轮转算法，线程调度，FIFO，时钟中断等其实并不陌生。一切只要你不懒和肯付出实际行动的难题都是纸老虎。






