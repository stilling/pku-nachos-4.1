内容一：总体概述
系统调用是操作系统功能实现中最核心的部分，通过系统调用，用户程序得以访问系统内核，实现由用户态和内核态的统一。
系统调用本质上是在实现操作系统内核态的同时，将开发过程中重复使用的，与硬件或者操作系统功能有密切联系的一部分常用指令序列抽取出来，使它们成为操作系统本身的一部分，即系统调用。
系统调用有两大原因，系统出错陷入和系统调用，使CPU的状态从用户态陷入内核态。
系统调用机制的设计分为四大部分：
● 中断/异常机制
● 选择特殊的指令陷入指令（即访管指令）：引发异常，完成用户态到内核态的切换
● 系统调用号和参数：每个系统调用都事先给定一个编号（功能号）
● 系统调用表：存放系统调用服务例程的入口地址

系统调用的执行过程为，当CPU执行到特殊的陷入指令时：
● 中断/异常机制：硬件保护现场，内核栈保护CPU；通过查中断向量表把控制权转给系统调用总入口程序
● 系统调用总入口程序：保存现场；将参数保存在内核堆栈里；通过查系统调用表把控制权转给相应的系统调用处理例程或内核函数
● 执行系统调用例程
● 恢复现场，返回用户程序


内容二：源代码阅读
在nachos中，系统调用用其他异常陷入的入口处理函数都是ExceptionHandle函数，只是陷入的类型为SyscallException。
Exception.cc，ExceptionHandler函数，ExceptionType是系统调用类型，系统调用号储存在readregister的第二个寄存器中，识别出需要进行的系统调用类型。
在syscall.h中定义了系统调用的接口，包括调用号。部分系统调用函数在ksycall.h中实现。
syscall.h这个头文件声明了所有的系统调用，首先是给每个系统调用设了一个系统调用号，同时定义了系统调用的模型。所有用户程序都需要include这个头文件。
start.s是一个汇编代码文件，从test目录下的Makefile文件下可以看出每个用户程序先生成.o文件，然后与start.o一起交叉编译为.coff文件，最后转换为可执行的.noff文件。因此，start.s相当于一个系统调用库，当用户程序执行系统调用时会执行对应的start.s中的代码。在start.s中把对应的系统调用号放入二号寄存器中，然后执行syscall汇编语句。这会使得machine.cc中的模拟指令运行函数OneInstruction调用RaiseException函数，这个函数我们之前就遇见过，它会调用exception.cc中ExceptionHandler函数，并且指明exception类似为系统调用。真正系统调用的实现全部在ExceptionHandler函数中实现，这也是我们本次lab主要完成的部分。

内容三：文件系统系统调用的实现
与文件系统相关的系统调用有：Create, Open，Close，Write，Read。
在文件系统部分，我们已经实现了相关功能，在系统调用中读取解析寄存器传入相关参数，再调用文件系统相关操作即可。
Create系统调用只有一个参数，就是指向文件名的char指针。从寄存器4可以读出文件名的地址，特别要注意的是，这个地址是虚拟地址，如果想通过这个地址访问到char指针指向的文件名内容，需要访问Nachos的物理内存，这就是Lab4的内容了。具体地，从物理内存以字节为单位地读取一个char型变量，直到读完整个文件名，从而知道了文件名的长度。然后再将整个文件名从内存中拷出来，这下就可以直接调用文件系统中的Create函数，新建一个文件，初始化文件大小为0。
Open系统调用也是只有一个参数代表文件名，实际上前面的过程和Create系统调用实现完全一样，只不过之后是调用文件系统中的Open函数。还有一点要注意的是Open系统调用要求返回一个文件描述符。恰好上个Lab已经实现了这一点，因此就直接返回文件的描述符即可。有一张表将文件的描述符和文件的文件头扇区号，依此扇区号建立一个OpenFile。
Close系统调用做的事情很简单，就是回收它的文件描述符。另一件事情是，上一个Lab为了做到文件访问的同步，我维护了一个全局文件链表，其中打开一个新文件会被加入链表，关闭一个文件会将链表中文件持有线程计数-1。现在，实现了系统调用，觉得应该把这两个函数分别放到这里，更为合适。
Write系统调用有三个参数，分别是字符缓存区、写入部分的大小以及要写入的文件的文件描述符。因为待写入的内容在用户空间，而现在是在内核空间，因此我定义了一个buffer将待写入的内容读进来，这一步需要经过虚实地址的转换。然后通过文件描述符打开文件，类似Open函数，再利用OpenFile的Write方法将内容写入。这里需要额外判断一下，如果文件描述符是1，即终端，则直接调用printf，而不用打开文件了。
Read系统调用类似Write系统调用有三个参数，分别是字符缓冲区、读入部分的大小以及要读入的文件的文件描述符。这里先判断文件描述符是否为0，即终端，是的话就调用scanf函数等待输入。否则，还是先打开文件，利用文件系统的Read方法将要读出的内容存入一个buffer中，然后再将buffer的内容写回到用户空间的相应位置，同样需要经历地址的虚实转换。与Write系统调用不同的是，Read系统调用还需要返回读出的字节数，这个值放置在寄存器2中。与Open，Close一样，上一个Lab为了做到文件访问的同步，加入了文件的读写锁，之前是加到了OpenFile的Write和Read里面。现在，实现了系统调用，这两个函数分别放到这里，更为合适。最后，一个统一的问题是，目前Nachos模拟系统调用指令之后不会增加PC，这意味着ExceptionHandler的相应内容总会被重复执行。为此，需要在每条处理系统调用的分支之后将PC加4。



内容四：用户程序相关系统调用的实现
nachos内部已经实现了线程的相关操作，读入用户程序运行进程也有相关的进程操作。
Exec系统调用有一个参数，表示可执行文件的文件名。这个系统调用让一个新线程去运行这个可执行文件。其实这有点像我们在Lab4中让多个线程运行用户程序的步骤，实际上我也是基本上把上次的实现搬到这里来了。首先还是先通过文件名打开对应的可执行文件，然后新建一个线程，初始化它的用户空间，设置它对应的内存交换文件(用于lazy-loading，在Lab4实现)。然后，令新线程调用Fork执行一个函数，在这个函数中进行机器页表和寄存器的切换，再调用machine->Run方法执行用户程序。此系统调用需要返回标识一个用户空间的SpaceId，我觉得因为一个线程就是对应的一个用户空间，因此我就直接返回新线程的tid了。Fork系统调用有一个参数，表示新fork出来的线程去执行的函数。这个系统调用与Exec不同，要求新fork的线程与原来的线程拥有相同的用户空间内容。为此，我给AddrSpace类添加了一个新的构造函数，接收参数不再是一个可执行文件，而是一个AddrSpace的指针，代表父线程的用户空间。最主要的事情，就是将父线程用户空间对应的交换文件拷贝到子线程地址空间中，具体地，利用文件系统的Read方法读出内容，再用Write方法写到新文件中。这里特别要注意的是，父线程此时可能还有未写回的部分，所以此时必须全部写回从而正确地记录父线程用户空间的状态。之后，还要注意调用Thread类的SaveUserState函数将父线程的全部寄存器保存。由于要求子线程下一步去执行func函数，因此在这里设置PC寄存器和NextPC寄存器，让它们分别指向func的地址以及func地址+4。最后，然后。令新线程调用Fork执行一个函数，在这个函数中进行机器页表和寄存器的切换，再调用machine->Run方法执行继续用户程序。Yield系统调用直接让currentThread执行Thread类的Yield方法。Join系统调用有一个参数，表示当前线程需要等待该线程ID的线程运行完毕再运行。为此，我给Thread类定义了一个静态变量JoinTable，记录有关Join操作的相关信息。它实际是一个map，key是线程id，value是一个List指针，直线的链表里是等待该线程的所有线程的实例(Thread*)。同时还在Thread下添加两个方法。一个方法是将自己加入到某线程的等待队列中，具体是从JoinTable中找到该队列然后把自己加入队列，如果没有队列则新建一个。另一个方法是将某线程的等待队列中的线程全部唤醒，实际上就是执行ReadyToRun。这个方法在Thread类的Finish中被调用，此时意味着该线程已经结束了，因此可以唤醒等待的线程。有了这些辅助，Join系统调用时很好写，就是将当前线程加入对应线程ID的等待队列中，然后关闭中断，自己调用Sleep。等待唤醒后，再恢复中断到原来状态。Exit系统调用直接让currentThread执行Thread类的Finish方法，当然同时应该记录退出码用于检测错误。